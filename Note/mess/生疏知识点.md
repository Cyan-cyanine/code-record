# 生疏知识点总结

## **关于char的-0 = -128的解释**

>引用（CSDN）：
>
>为什么能用它表示 -128 进行运算，如果不要限制为 char 型（即不要限定是 8 位），再来看，-128 的原码：1 1000 0000 ，9位，最高位符号位，再算它的反码：1 0111 1111，进而，补码为：1 1000 0000，这是 -128 的补码，发现和原码一样，1 1000 0000 和 1000 0000 相同？如果说一样的人真是瞎了眼了，所以，-128 的原码和 -0(1000 000) 的原码是不同的，但是在 char 型中，是可以用 1000 000 表示 -128 的，关键在于char 是 8 位，它把 -128 的最高位符号位 1 丢弃了，截断后 -128 的原码为 1000 000 和 -0 的原码相同，也就是说 1000 0000  和 -128 丢弃最高位后余下的 8 位相同，所以才可以用 -0 表示 -128，这样，当初剩余的 -0(1000 0000)，被拿来表示截断后的 -128，因为即使截断后的 -128 和 char 型范围的其他 (-127~127) 运算也不会影响结果， 所以才敢这么表示 -128。

## 两种变量实现整型数据交换：

- a=a+b;   *//a=91;* 	

  b=a-b;	*//91-89=2;* 	

  a=a-b;	*//91-2=89;*

- a=a^b;  *//a=7   等同于a^b,注释里的a,b值等于原始数据a,b的值* 	

  b=a^b;  *//b=2   等同于a^b^b* 	

  a=a^b;  //a=5   这时的b等同于a,这里的a等同于a^b所以等同于a^a^b*

- a = a + b – (b = a);

## 定义变长数组的技巧

若有结构体：

```
struct node
{
	int a;
	char b;
	float c;
	char msg[0];
};
```

当我需要定义一个用于接收消息的struct node型的变量时，我可以根据消息的长度申请变长堆内存。

```
char buf[100];
fgets(buf,100,stdin);
char *p = malloc(sizeof(struct node)+strlen(buf)+1);	//其中1为'\0'
```

## main函数原型

```
int main(int argc, char *argv[])
{
	return 0;
}
```

- argc——argument count，表示参数个数，argc初始值为1，表示当前路径
- argv——argument vector，参数指针，表示外部传参的内容，argv[0]默认为当前执行的文件路径

- 外部传参方式
  - `./需要执行的文件名 外部参数1(argv[1]) 外部参数2(argv[2])`

## 大端存储与小端存储

> 例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

## Linux

### 用户信息存储的文件

- etc/passwd(7列):用户基本信息文件

  - 例:`root:x:0:0:5:/root:/bin/bash`
    - 1. root:用户名
      2. x:密码占位符
      3. 0:UID，用户身份证号，0为最高权限账号，1~499是系统用户，>500为非系统用户，1000+是普通用户
      4. 0:GID，group组号，0为最高权限账号，1~499是系统用户，>500为非系统用户，1000+是普通用户
      5. root:用户描述
      6. /root:家目录路径
      7. /bin/bash:登录shell

- /etc/shadow(8列):用户密码信息文件

  - 例`root:$6$……G1b1:19047:3:4:5:6:7:8`
    1. root:用户名
    2. 加密值:
       `$6$`开头的，表明是用SHA-512加密的
       `$1$`表明是用MD5加密的
       `$2$`是用Blowfish加密的
       `$5$`是用SHA-256加密的。
    3. 最后一次修改时间：1970年1月9日到今天过了多少天
    4. 最小间隔，第2次修改密码需要等待的时间
    5. 最大时间间隔，密码有效期，9999代表无限期
    6. 警告时间，提示修改密码的时间
    7. 不活动时间，表示用户没有登录活动，但账号仍能保持使用的有效最大天数
    8. 账号失效时间，过了该天数后账号失效
    9. 保留

- /etc/group：组信息文件

  - 例：`root:x:0:`
    1. root：组名
    2. x：组密码
    3. 0：组ID，0为最高权限账号，1~499是系统用户，>500为非系统用户，1000+是普通用户
    4. 组成员

## 关于fgets末尾结束符的问题

> 若fegts读取的字符数小于n，则会全部读取并且在最后一个字符后面添加'\0'
> 若读取的字符数等于n，则最多读取n-1个字符，第n个字符为'\0'
> 在读取stdin时，我们输入回车代表输入结束，回车符会被fgets一起读进缓存

## C语言用户录入字符串的处理方式

```c
bool getStrAndCheck(char *string,int maxSize) //录入字符串并检查是否超出范围
{
    bzero(string,maxSize);
    char format[10];
    sprintf(format,"%%%ds",maxSize-1);    
    scanf(format,string);                                             
    cleanIo();
    if(string[maxSize-2]==0)
        return true;
    else
        return false;
}
```

- `bzero(string,maxSize);`初始化string

- `sprintf(format,"%%%ds",maxSize-1);`maxSize-1的运算结果给到%d,并将该字符串传入到format中,这样做可以保证下一步scanf录入到string时，长度受到maxSize的控制，防止越界操作影响到结构体的下一个成员。
  为什么不是maxSize而是maxSize-1？若此处为maxSize，那么用户可以使用到字符数组的最后一个元素值，当该值被使用，scanf会在录入最后一个字符时尾部自动添加\0，这会导致数组越界，那么如果string是结构体里的一位成员，它的越界访问将会影响到下一个成员的取值。★★★

- `cleanIo();`清空io缓冲区

  ```c
  void cleanIo()  //清空缓冲区函数
  {
      while(getchar()!='\n');
  }
  ```

- `if(string[maxSize-2]==0)`，string[maxSize-1]为数组的最后一个元素，它必须为0，所以比较maxSize-1是毫无意义的，相当于牺牲了一个char，保证录入时不会发生越界。

